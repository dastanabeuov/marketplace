require "nokogiri"
require "open-uri"
require "uri"
require "net/http"

namespace :parse do
  desc "Ежедневный парсинг одной страницы брендов с baumuller.kz"
  task daily_brands: :environment do
    # Список компаний для парсинга
    # reserve_target_companies = [
    #   "Ariel", "Waukesha", "Caterpillar", "Dresser-Rand", "Mycom",
    #   "Ajax", "Sullair", "Ekomak", "Atlas Copco", "Gea",
    #   "Howden", "Perkins", "Cummins", "FG Wilson"
    # ]

    target_companies = [
      "Caterpillar", "Atlas Copco", "Gea",
      "Howden", "Cummins"
    ]

    # Преобразуем имена компаний в нижний регистр для регистронезависимого сравнения
    target_companies_downcase = target_companies.map(&:downcase)

    base_url = "https://baumuller.kz"
    max_retries = 3
    found_companies = []

    # Получаем текущую страницу для парсинга из настроек или переменной окружения
    current_page = get_current_parsing_page

    puts "Начинаем ежедневный парсинг. Страница: #{current_page}"
    puts "Целевые компании: #{target_companies.join(', ')}"

    brands_url = "#{base_url}/brands?page=#{current_page}"
    puts "Загружаем страницу брендов: #{brands_url}"

    begin
      html = URI.open(brands_url,
        read_timeout: 30,
        "User-Agent" => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
      )
      doc = Nokogiri::HTML(html)
    rescue OpenURI::HTTPError => e
      puts "Ошибка при загрузке страницы: #{e.message}"
      log_parsing_error("HTTP Error на странице #{current_page}: #{e.message}")
      return
    rescue => e
      puts "Непредвиденная ошибка: #{e.message}"
      log_parsing_error("Непредвиденная ошибка на странице #{current_page}: #{e.message}")
      return
    end

    # Находим все карточки брендов на странице
    brand_blocks = doc.css("div.card")

    if brand_blocks.empty?
      puts "Страница #{current_page} не содержит брендов. Сбрасываем счетчик страниц."
      reset_parsing_page
      log_parsing_result(current_page, 0, 0, "Страница пуста, сброшен счетчик")
      return
    end

    puts "Найдено #{brand_blocks.size} брендов на странице #{current_page}"
    processed_brands = 0
    total_products = 0

    brand_blocks.each_with_index do |brand_block, index|
      # Добавляем случайную задержку между обработкой брендов (1-3 секунды)
      sleep(rand(1..3))

      # Извлекаем название бренда
      brand_name = brand_block.at_css("div.card-body h5")&.text&.strip ||
                   brand_block.at_css("div.card-body")&.text&.strip

      next unless brand_name && !brand_name.empty?

      # Проверяем, входит ли бренд в список целевых компаний
      is_target = target_companies_downcase.any? { |target| brand_name.downcase.include?(target) }

      unless is_target
        puts "  Пропускаем бренд: #{brand_name} (не входит в целевой список)"
        next
      end

      found_companies << brand_name
      processed_brands += 1
      puts "\nОбрабатываем бренд: #{brand_name}"

      # Получаем ссылку на страницу бренда
      brand_link = brand_block.at_css("a")&.attr("href")
      next unless brand_link

      brand_url = brand_link.start_with?("http") ? brand_link : "#{base_url}#{brand_link}"

      # Получаем изображение бренда
      image_tag = brand_block.at_css("a img")
      image_url = image_tag ? image_tag["src"] : nil

      if image_url
        image_url = image_url.start_with?("http") ? image_url : "#{base_url}#{image_url}"
      end

      # Создаем или находим компанию
      company = Company.find_or_initialize_by(name: brand_name)

      if company.new_record?
        company.save!
        puts "  Создана компания: #{company.name}"
      else
        puts "  Компания уже существует: #{company.name}"
      end

      # Прикрепляем изображение к компании
      attach_image_to_company(company, image_url, max_retries) if image_url

      # Парсим продукты для этого бренда (только первую страницу)
      brand_products_count = parse_brand_products_single_page(base_url, brand_url, company, max_retries)
      total_products += brand_products_count

      # Добавляем задержку между брендами
      sleep(rand(2..5))
    end

    # Обновляем номер страницы для следующего дня
    increment_parsing_page

    # Логируем результат
    log_parsing_result(current_page, processed_brands, total_products, found_companies.join(", "))

    puts "\nЕжедневный парсинг завершен."
    puts "Страница: #{current_page}"
    puts "Обработано брендов: #{processed_brands}"
    puts "Обработано продуктов: #{total_products}"
    puts "Найдены компании: #{found_companies.join(', ')}" if found_companies.any?
  end

  # Парсинг продуктов бренда - только первая страница
  def parse_brand_products_single_page(base_url, brand_url, company, max_retries)
    products_count = 0

    puts "  Загружаем первую страницу продуктов: #{brand_url}"

    # Добавляем задержку перед запросом
    sleep(rand(2..4))

    begin
      html = URI.open(brand_url,
        read_timeout: 30,
        "User-Agent" => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
      )
      doc = Nokogiri::HTML(html)
    rescue OpenURI::HTTPError => e
      puts "  Ошибка при загрузке страницы продуктов: #{e.message}"
      return 0
    rescue => e
      puts "  Непредвиденная ошибка при загрузке страницы продуктов: #{e.message}"
      return 0
    end

    # Находим все карточки продуктов на странице
    product_cards = doc.css("div.card")

    if product_cards.empty?
      puts "  Продукты не найдены для бренда #{company.name}"
      return 0
    end

    puts "  Найдено #{product_cards.size} продуктов"

    product_cards.each do |card|
      # Добавляем задержку между продуктами
      sleep(rand(1..2))

      # Извлекаем данные о продукте
      product_name = card.at_css("div.card-body a")&.text&.strip
      next unless product_name && !product_name.empty?

      # Получаем ссылку на детальную страницу продукта
      product_link = card.at_css("div.card-body a")&.attr("href")
      product_url = nil
      if product_link
        product_url = product_link.start_with?("http") ? product_link : "#{base_url}#{product_link}"
      end

      # Получаем изображение продукта
      image_tag = card.at_css("a img")
      image_url = image_tag ? image_tag["src"] : nil

      if image_url
        image_url = image_url.start_with?("http") ? image_url : "#{base_url}#{image_url}"
      end

      # Создаем или находим продукт
      product = Product.find_or_initialize_by(name: product_name)

      # Дополнительные поля
      product.producer = company.name if product.producer.blank?

      # Получаем дополнительные данные с детальной страницы (с ограничениями)
      if product_url && product.new_record?
        fetch_product_details(product, product_url, max_retries)
      end

      if product.new_record?
        product.save!
        puts "    Создан продукт: #{product.name}"
      else
        if product.changed?
          product.save!
          puts "    Обновлен продукт: #{product.name}"
        end
      end

      # Прикрепляем изображение к продукту
      attach_image_to_product(product, company, image_url, max_retries)

      # Создаем связь между продуктом и компанией
      create_product_company_relation(product, company)

      products_count += 1
    end

    puts "  Обработано продуктов для бренда #{company.name}: #{products_count}"
    products_count
  end

  private

  # Получение текущей страницы для парсинга
  def get_current_parsing_page
    # Можно использовать базу данных, Redis, или файл
    # Пример с использованием переменных окружения или файла
    if File.exist?("tmp/parsing_page.txt")
      File.read("tmp/parsing_page.txt").to_i
    else
      1
    end
  end

  # Увеличение номера страницы
  def increment_parsing_page
    current_page = get_current_parsing_page
    new_page = current_page + 1

    # Создаем директорию если не существует
    FileUtils.mkdir_p("tmp") unless Dir.exist?("tmp")

    File.write("tmp/parsing_page.txt", new_page)
    puts "Следующая страница для парсинга: #{new_page}"
  end

  # Сброс счетчика страниц
  def reset_parsing_page
    FileUtils.mkdir_p("tmp") unless Dir.exist?("tmp")
    File.write("tmp/parsing_page.txt", 1)
    puts "Счетчик страниц сброшен на 1"
  end

  # Логирование результатов парсинга
  def log_parsing_result(page, brands_count, products_count, companies_found)
    log_entry = {
      date: Date.current,
      page: page,
      brands_processed: brands_count,
      products_processed: products_count,
      companies_found: companies_found,
      status: "success"
    }

    log_file = "log/daily_parsing.log"
    FileUtils.mkdir_p("log") unless Dir.exist?("log")

    File.open(log_file, "a") do |file|
      file.puts "#{Time.current}: #{log_entry.to_json}"
    end
  end

  # Логирование ошибок
  def log_parsing_error(error_message)
    log_entry = {
      date: Date.current,
      error: error_message,
      status: "error"
    }

    log_file = "log/daily_parsing.log"
    FileUtils.mkdir_p("log") unless Dir.exist?("log")

    File.open(log_file, "a") do |file|
      file.puts "#{Time.current}: ERROR - #{log_entry.to_json}"
    end
  end

  # Прикрепление изображения к компании
  def attach_image_to_company(company, image_url, max_retries)
    return if company.image.attached?

    retries = 0
    begin
      sleep(rand(1..2)) # Задержка перед загрузкой изображения

      downloaded_image = URI.open(image_url,
        read_timeout: 30,
        "User-Agent" => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
      )
      filename = File.basename(URI.parse(image_url).path)
      filename = "#{SecureRandom.hex(8)}.jpg" if filename.empty? || filename == "/"

      company.image.attach(io: downloaded_image, filename: filename)
      puts "  Изображение прикреплено к компании: #{company.name}"
    rescue => e
      retries += 1
      if retries <= max_retries
        puts "  Ошибка загрузки изображения для #{company.name}: #{e.message}. Попытка #{retries}/#{max_retries}"
        sleep(rand(2..4))
        retry
      else
        puts "  Не удалось загрузить изображение для #{company.name} после #{max_retries} попыток"
      end
    end
  end

  # Получение деталей продукта
  def fetch_product_details(product, product_url, max_retries)
    retries = 0
    begin
      sleep(rand(2..4)) # Задержка перед запросом

      product_html = URI.open(product_url,
        read_timeout: 30,
        "User-Agent" => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
      )
      product_doc = Nokogiri::HTML(product_html)

      # Извлекаем описание
      description = product_doc.at_css("div.description")&.text&.strip
      product.description = description if description && !description.empty?

      # Извлекаем цену
      price = product_doc.at_css("div.price")&.text&.strip
      product.price = price if price && !price.empty?

      # Извлекаем код продукта
      product_code_text = product_doc.at_css("div.product-code")&.text&.strip
      if product_code_text && product_code_text.match(/\d+/)
        product_code = product_code_text.match(/\d+/)[0]
        product.product_code = product_code.to_i if product_code.to_i > 0
      end
    rescue => e
      retries += 1
      if retries <= max_retries
        puts "    Ошибка при загрузке детальной страницы продукта: #{e.message}. Попытка #{retries}/#{max_retries}"
        sleep(rand(3..6))
        retry
      else
        puts "    Не удалось загрузить детальную страницу продукта после #{max_retries} попыток"
      end
    end
  end

  # Прикрепление изображения к продукту
  def attach_image_to_product(product, company, image_url, max_retries)
    return if product.image.attached?

    if image_url
      retries = 0
      begin
        sleep(rand(1..2))

        downloaded_image = URI.open(image_url,
          read_timeout: 30,
          "User-Agent" => "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        )
        filename = File.basename(URI.parse(image_url).path)
        filename = "#{SecureRandom.hex(8)}.jpg" if filename.empty? || filename == "/"

        product.image.attach(io: downloaded_image, filename: filename)
        puts "    Изображение прикреплено к продукту: #{product.name}"
      rescue => e
        retries += 1
        if retries <= max_retries
          puts "    Ошибка загрузки изображения для продукта #{product.name}: #{e.message}. Попытка #{retries}/#{max_retries}"
          sleep(rand(2..4))
          retry
        else
          puts "    Не удалось загрузить изображение для продукта #{product.name} после #{max_retries} попыток"
        end
      end
    elsif company.image.attached?
      # Используем изображение компании
      product.image.attach(company.image.blob)
      puts "    Изображение компании прикреплено к продукту: #{product.name}"
    end
  end

  # Создание связи продукт-компания
  def create_product_company_relation(product, company)
    unless ProductCompany.exists?(product_id: product.id, company_id: company.id)
      ProductCompany.create!(product_id: product.id, company_id: company.id)
      puts "    Связь продукт-компания создана: #{product.name} - #{company.name}"
    end
  end
end
